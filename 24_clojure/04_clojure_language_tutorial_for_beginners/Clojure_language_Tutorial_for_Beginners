Clojure language Tutorial - for Beginners
https://www.youtube.com/watch?v=zFPiPBIkAcQ

# Clojure

## Intro

Created by Rich Hickey in 2007

Dialect of Lisp.
Macros code as input and code as output.

Dynamically typed and functional programming language
Function programming 
* avoid mutable stage (any data than can change)
* referantial transparent function - does not change state - pure function
	* same input same output always
* instead modify existing create new modified copies	
 	* persistent collections solves the problem of memory (new and olds el. are ahared in memory)

Reference types
* holds mutable state that is coordinate across threads without locks
* sync threads without looks

Compiles to Java bytecode, runs on the JVM and every clojure data type has correspoing Java class
Removes inheritance and encapsulation but embraces polymorphism

## Clojure Source Code

text data/source code-> AST (Abstract syntax tree - an object representation of source code)
Ex: function object contains prams objects statement objects and so on 

Reader translates source code into reader data (AST)
Evaluator translated reader data into a runnable program

### How Reader read code
"this is string"
'H' Java Character
53 Long (by default Clojure.BigInt)
6.3 Double
nil null
foo symbol - identifier treated as value
:foo keyword - constant value 
(1 2 3) list 
* ordered collection implemented as singly likedin list 
* not good for random access
[] vector
* ordered collection 
* elements stored as tree of nodes
* better random access than list 
{"foo" 3} map
* unordered key value paris 
* key number, string, keyword
* value anything
#{} set

List, vector, map, set are presistent collections

(defn hello-world []
	(println "Hello, world"))
symbols: defn, hello-world println	

Vars and namespaces
* var (varible) - holds a mutable reference to another object
* namespace maps symbols to vars (key is symbol value is var)
	* it is mutable it can change during the curse of the program
	* each namespace is uniqe
Example:
namesace cat
	have symbol mittens -> var (mapped to)

Clojure core namespace contains nearly 500 functions

### How evaluator works
Symbols resolve into the values held in vars

fully qualified symbol: namespace/name Example: animal/cat
curent namespace symbol cat (does not contains name of namspace/)

When intepreter starts clojure core is current namespace
then it swiches 

List is treated as function call 
(foo 51 "hello" bar)
* arguments are resolved before passin to function

Macros
when evalujators see macros it passes reader data itself and macros should return reder data is itself evaluated 
(foo 51 "hello" bar)
* if foo macro bar is not resolved but passes as param to function
* macro can return macro it repeates until reader data is returned

Evaluator works outside in
(def james (+ 8 2))
- starts evaluting def 
- evaluates + and send result as param to def
- ends evaluating def

Special forms
* def
	* assigns a value to a var in the current namespace
	* creates a car if doesn't already exist
	* (def alice 3) -> alice is symbol 
* fn 
	* returns a new function object 
	* when called fn returns the value of the last expression in its body
	* [x y & z] - fn params takes two or more arguments 
		* z is ordered collection
		* [& a] - takes zero or more agruments
* defn (def and fn combined)
* if 
	* (if condition ex-true ex-false)
	* condition returns any value than false or nill ex-true is evaluated
	* you can omit ex-false it evaluates nil
* do 
	* body of n expressions 
	* returns value of last expression
* let 
	* (let [bindings] body)
	* local values for body 
	* returns value of last expression in body
* recur 
	* jumps executions back to last recursion point with new binding values
	* fix for stack oveflow problem
	* only in tail positions from perspective of compiler (all local variables in fn are not needed so memory can be set free)
	* explicit tail recusrice call (because of the limitation of JVM)
	* call fn in which is containder if you have two fn it calls the once in which it is 
* loop 
	* (loop [bindings] body)
	* same as let but it gives recursion point for recur so last statemetn set up new values for bindings

* quote
	* (quote el)
	* returns an element unevaluated
	* some fn expext list as argumetns  
	* mainly in macros used to return reader data 
	* special syntax '
* try and throw
	* (try body catch-clauses)
	* (catch class ex-binding body)
	* (throw ex)
	* an optional finnally 
* var 
	* symbol in namespace returns value hold in var 
	* get var object itself (var foo/x)
* new
	* returns a new instance of a Java class
	* (new class arg) (new java.io.FIle "myfile.dat"
* . (dot)
	* returns the value of Java filed or invokes a Java method
	* (. class filed) or (. class method) or (. instance filed) Ex: (. java.lang.Math PI)
* set!
	* (set! dot.form expression)
	* assigng value of expression to the filed or an instance or class specified by a dot form
	* Ex: (set! (. foo bar) 3)

Macro cond 
* macro form of if-else 
* first true its expresion is executed rest is ignored

## Collection types

Collection types are fully persistent

### List collection type
A persistent list is a chain of nodes:
	head -> node -> node -> node -> nil
random access not good
replacing elements in list are not good
we dont use them for storing data

### Vector collection type
A persistent vector is a trie of nodes
Elements of the vector are stored in the leaf nodes
vector object reference to the head
random access is better 
To create a new vector with a changes element we copy and modify the cahin of nodes that contains that element (Old vector exist untached)
replacing and lookap are overhead operations but still good price to pay for having immutability 

### Hashmap collection type
* impl. similary as vector 
* key values are stored in node

### Core collection fn
* count
* list?
* vector?
* map?
* contains?
* conj - new coll with added el or key-value
	- for vector at the end
	- for list at the start
* assoc - new coll with added/modified element for key of index
* dissoc - new map with removed key
* merge - combine two maps in one
* get - returns value at index/key
* pop - returns new coll without 
	- for vector without last
	- for list without first
* peek - returns first 
	 - for vector last
	 - for list first
	 
### Seqeunce 
Goal fast iteration, cheaper than vector 
Perfromant and statelles iteration over collections
	(loop [x 1 2 3 4]
		(println (first x))
		(recur (rest x)))

Interface 
Supports two operations
* first - returns first el
* rest - returns all elements except first
* impl. the Java interace clojure.lang.Iseq
* seq - returns a sequence 
	- map and vector has to be convertes do seq ? 
	- vector is not because it is not cheao to have rest operation 
* most of the functinos that operates on seq (like first and rest) call seq on thier arument
	(fist '(123)) same as (first (seq '(123)))

Cons (construct list)
* seq type which holds a value and a reference to another seq
* creates new cons givem valuone and a seq
* diff betwen list is that list can only point to list node here we can point to any seq node type (vector map)
* good for lazy seq 

A lazy sequence 
Generates its elements only as needed
* TDO what fn returns lazy or not lazy 

Invoke fn that expect eager seq does not work and 
	it still the program like (count ) ; seq should have end 

Create fn 
	range  
	repeat - repat value infintie 
	repeatedly - repeat value infinite (value generated by fn)
	iterate - like repeately but fn recived as arument previusly el
	cycle - repeates elemnts of coll infinite

	lazy seq - macto creates a lazy seq from body, last expression in body should return seq, body is only run the first time we invove first or rest on the lazy 	
	- in practice body should recursivle return another lazy seq
	(same efect if we return a const with a lazy)
			
Does not have to be infinite 	

Core sequence functions
* next - like rest when empty returns nill
* nth - like get but for seq pass index 
* apply - invoke fn with arg from seq
* map  - returns lazy seq, invoke fn on each el
* reduce - result on lazy seq 
* reductions - intermedita values in lazy of reduce
* filter - returns lazy seq for wich fn returns true
* remove - returns lazy seq for with fn returns false
* take - returns lazy seq of the first n elements
* take-last - returns lazy seq of the last n elements
* take-nth - returns lazy seq of every nth element
* concat - lazy seq concatantes 
* interleave - returns lazy seq from multiple collections round-robin
* interpose - returns lazy seq a value is inserted between el of a seq
* distinct - returns lazy seq uniqe
* reverse - returns lazy seq in reverse
* flatten  - returns lazy seq flatten
* sort - - returns lazy seq sorted

### Namespaces
Each namespace is known by a symbolic name and maps symbols to vars
At any one time one namespace is the "current namespace" used by the evaluator
At program start the currnet namespace is user. 
The user namespace contains all of the elements of clojure.core

(in-ns 'foo)
- makes current namespace (creates if not exist)

Mapings
* symbol to var (interned)
	Normal with def/defn special form
* symbol to var (referred)
	Created with refer function (in require fn)
	refer to other namespace 
	has access only to interned (not referrd) symbols from refered namespace
	Example: 
	(foo/bar)
	(clojure.core/refer 'foo)
	(bar) ; no need to have foo/ you can use only namliase 
* symbol to class
	(clojure/core/import java.util.Date)
* symbol to namespace
	Alias function as in
	(clojure.core/alias 's 'supercallfragiledlistblablablnamespace)
	(s/foo)  ; same as supercallfragiledlistblablablnamespace/foo

* same namspace are shared with vars and fn (be carfeul on naming they can override)
	* list 1
	
Read-Eval a file with the load function	
On start cojure runtime specify one file to run then in code you can load and run other namespaces with
	(load "bar/baz")
	- relative to java class claspath
	
A lib is a source file located at a path that corresponds to a symbolic name 
By convention a lib creates a namespace of the same symbolic name

To split a lib into multiple soruce files, common practice is to place other files in the same 
directory and load them from the lic file
; in lib bar/baz.clj
(in-ns 'bar.baz)
(load "otherfile")
(load "otherfile2")

The require function loads a liv by its symbolic name the current namespace stays same
(require 'clojure.java.io)

(use 'clojure.java.io)
Same as require but referes the namespace of the same name

The ns macto bundles the functionality of in-ns, requires, use and import 
(ns foo.bar
	(:require clojure.contrib.sql :as xxx)
	(:use clojure.test) -- depreceted. solution use refer insude require or all 
	(:import java.util.Date))
- because it is makro we don need to ' (quote) symbols that refere to namespaces
- TODO what is diff use and requires

### Metadata
Any Clojure object (expect numbers, booleans, strnigs and nill) can have an sooicated map as metadata
(with-meta [1 2] {:so-meta true})
or 
^{:so-meta true} [1 2]

Metadata - data that anotates other data

Equality test (= 1 2) ignores metadata

### Arities
A clojure function can have multiple arities (multiple arguments expected by function)
each params has its own body 

[a & b]
* b is the rest params and it represet collection of params

### Destructuring
BInd elements of collections to symbols
Put names in vector for vector
[a b c] [1 2 3] 
Put names in map for map - get values
{my-x :x} {:x 1 :y 2}
or 
{:keys [x z]}

Providen expressiom must mirror the target

### Set
Every element of a set occurs only once 
sets elements are just keys (impleemented same as map)
* hash-set (no order) and tree-set (sorted order, fn name is sorted-set)
* collection fn works on set
* can not remove with remove fn but use disj (disj set el)


Collection objects are functions
calld with params return value at index/key
([10 20 30] 1) returns 10

Keywords are functions
(:y {:x 1 :y 2})

#() - shorthand for a fn
%2 - param at position 2
%1 & - param at position 1

Stao: 01:29
